<html>

<head>
    <script src="lib/bindings/utils.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css"
        integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js"
        integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>


    <center>
        <h1></h1>
    </center>

    <!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous" />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
        crossorigin="anonymous"></script>


    <center>
        <h1></h1>
    </center>
    <style type="text/css">
        #mynetwork {
            width: 100%;
            height: 750px;
            background-color: #ffffff;
            border: 1px solid lightgray;
            position: relative;
            float: left;
        }
    </style>
</head>


<body>
    <div class="card" style="width: 100%">


        <div id="mynetwork" class="card-body"></div>
    </div>




    <script type="text/javascript">

        // initialize global variables.
        var edges;
        var nodes;
        var allNodes;
        var allEdges;
        var nodeColors;
        var originalNodes;
        var network;
        var container;
        var options, data;
        var filter = {
            item: '',
            property: '',
            value: []
        };

        var nodeToggleStatus = {};


        // This method is responsible for drawing the graph, returns the drawn network
        function drawGraph() {
            var container = document.getElementById('mynetwork');

            // parsing and collecting nodes and edges from the python
            nodes = new vis.DataSet([{"color": "blue", "id": 1, "label": ".M", "shape": "dot", "size": 50.0, "title": "2"}, {"color": "blue", "id": 2, "label": ".A", "shape": "dot", "size": 16.666666666666668, "title": "3"}, {"color": "blue", "id": 3, "label": ".B", "shape": "dot", "size": 23.333333333333332, "title": "0"}, {"color": "blue", "id": 4, "label": ".C", "shape": "dot", "size": 33.333333333333336, "title": "0"}, {"color": "blue", "id": 13, "label": ".C", "shape": "dot", "size": 33.333333333333336, "title": "2"}, {"color": "blue", "id": 5, "label": ".D", "shape": "dot", "size": 10.0, "title": "2"}, {"color": "blue", "id": 6, "label": ".A", "shape": "dot", "size": 16.666666666666668, "title": "0"}, {"color": "blue", "id": 8, "label": ".C", "shape": "dot", "size": 33.333333333333336, "title": "0"}]);
            edges = new vis.DataSet([{"arrows": "to", "color": "gray", "from": 2, "to": 3}, {"arrows": "to", "color": "gray", "from": 2, "to": 4}, {"arrows": "to", "color": "gray", "from": 13, "to": 2}, {"arrows": "to", "color": "gray", "from": 13, "to": 13}, {"arrows": "to", "color": "gray", "from": 2, "to": 13}, {"arrows": "to", "color": "gray", "from": 1, "to": 2}, {"arrows": "to", "color": "gray", "from": 5, "to": 6}, {"arrows": "to", "color": "gray", "from": 5, "to": 8}, {"arrows": "to", "color": "gray", "from": 1, "to": 5}]);

            nodeColors = {};
            allNodes = nodes.get({ returnType: "Object" });
            for (nodeId in allNodes) {
                nodeColors[nodeId] = allNodes[nodeId].color;
            }
            allEdges = edges.get({ returnType: "Object" });
            // CUSTOM START ###
            outMap = {}; // for quick access to out-going edges (key=nodeId, value=edgeId)
            inMap = {}; // for quick access to incoming edges (key=nodeId, value=edgeId)
            backEdges = {}; // TODO: Implement custom backedge drawing to avoid messy default hierarchical layout
            for (edgeId in allEdges) {
                // all edges hidden by default
                edges.update([{id: edgeId, hidden: true}]);
                // store outgoing edges from node
                if ((allEdges[edgeId].from in outMap) == false) {
                    outMap[allEdges[edgeId].from] = new Set([]);
                }
                outMap[allEdges[edgeId].from].add(allEdges[edgeId]);
                // store incoming edges to node
                if ((allEdges[edgeId].to in inMap) == false) {
                    inMap[allEdges[edgeId].to] = new Set([]);
                }
                inMap[allEdges[edgeId].to].add(allEdges[edgeId]);
            }
            for (nodeId in allNodes) {
                // only run on root nodes
                if ((parseInt(nodeId) in inMap) == false) {
                    // calc node depth starting from root
                    calcDepth(allNodes[nodeId], 0, new Set([]));
                    // delete all children
                    deleteChildren(allNodes[nodeId]);
                }
            }

            function deleteChildren(currNode) {
                if (nodes.get(currNode.id) != null) {
                    currNode.displayChildren = false;
                }
                if (currNode.id in outMap) {
                    for (const edge of outMap[currNode.id]) {
                        edges.remove(edge.id);
                        neighbourNode = allNodes[edge.to];
                        if (neighbourNode.depth <= currNode.depth) {
                            continue; // do not delete lower depth nodes (to handle recursion)
                        }
                        if (nodes.get(neighbourNode.id) == null)
                            continue; // already deleted
                        nodes.remove(neighbourNode.id);
                        deleteChildren(neighbourNode);
                    }
                }
            }

            function addChildren(currNode, depth, maxDepth) {
                if (depth == maxDepth) {
                    return;
                }
                pos = network.getPosition(currNode.id);
                currNode.displayChildren = true;
                if (currNode.id in outMap) {
                    for (const edge of outMap[currNode.id]) {
                        edges.add(edge);
                        edge.physics = false;
                        // edges.update([{id: edge.id, physics: false}]);
                        neighbourNode = allNodes[edge.to];
                        if (neighbourNode.depth <= currNode.depth) {
                            continue; // do not re-add lower depth nodes (to handle recursion)
                        }
                        if (nodes.get(neighbourNode.id) != null) {
                            continue; // already added
                        }
                        neighbourNode.fixed = true;
                        neighbourNode.displayChildren = false;
                        neighbourNode.x = pos.x;
                        nodes.add(neighbourNode);
                        addChildren(neighbourNode, depth+1, maxDepth);
                    }
                }
            }

            function calcDepth(currNode, depth, visited) {
                if(visited.has(currNode.id)) {
                    return; // reached a visited node; stop
                }
                currNode.depth = ((currNode.depth == undefined) ? depth : min(currNode.depth, depth));
                currNode.level = depth;
                currNode.minLevel = depth;
                currNode.fixed = true;
                visited.add(currNode.id);
                if (currNode.id in outMap) {
                    for (const edge of outMap[currNode.id]) {
                        calcDepth(allNodes[edge.to], depth+1, visited);
                    }
                }
            }
            // CUSTOM END ###
            // adding nodes and edges to the graph
            data = {nodes: nodes, edges: edges};
                
            const options = {
                "layout": {
                    "improvedLayout":true,
                    "clusterThreshold": 150,
                    "hierarchical": {
                        "enabled": true,
                        "levelSeparation": 150,
                        "nodeSpacing": 200,
                        "treeSpacing": 200,
                        "blockShifting": true,
                        "edgeMinimization": true,
                        "parentCentralization": true,
                        "direction": "UD",        
                        "sortMethod": "hubsize",  
                        "shakeTowards": "roots"  
                    }
                },
                "edges": {
                    "hoverWidth": 0,
                    "selectionWidth": 0,
                    "width": 1
                },
                "interaction": {"hover": true}
            }
                
            network = new vis.Network(container, data, options);
            // CUSTOM START ###
            network.on('click', function (properties) {
                var ids = properties.nodes;
                var clickedNode = nodes.get(ids)[0]; // only pick first node in clicked nodes
                if (clickedNode !== undefined) {
                    console.log("clicked: " + JSON.stringify(clickedNode));
                    // toggle display children
                    if (clickedNode.displayChildren) {
                        deleteChildren(clickedNode);
                    } else {
                        addChildren(clickedNode, 0, 1);
                    }
                }
            });
            network.on("hoverNode", function (properties) {
                var id = properties.node 
                if (id in outMap) {
                    network.canvas.body.container.style.cursor = 'pointer';
                    nodes.update([{id: id, size: allNodes[id].size+3}]);
                }
                
            });
            network.on("blurNode", function (properties) {
                network.canvas.body.container.style.cursor = 'default'
                var id = properties.node
                if (id in outMap) {
                    nodes.update([{id: id, size: allNodes[id].size-3}]);
                }
            });
            // CUSTOM END ###
            return network;

        }
        drawGraph();
    </script>
</body>

</html>